<?php

declare(strict_types=1);

namespace Crell\Carica\Router\FastRoute;

use Crell\AttributeUtils\Analyzer;
use Crell\AttributeUtils\ClassAnalyzer;
use Crell\AttributeUtils\MemoryCacheAnalyzer;
use Crell\Carica\ActionClass;
use Crell\Carica\Router\RouteDefinition;
use FastRoute\DataGenerator;
use FastRoute\DataGenerator\GroupCountBased;
use FastRoute\RouteCollector;
use FastRoute\RouteParser;
use FastRoute\RouteParser\Std;

class PreParsingRouteCollector extends RouteCollector
{
    public function __construct(
        RouteParser $routeParser = new Std(),
        DataGenerator $dataGenerator = new GroupCountBased(),
        private readonly ClassAnalyzer $analyzer = new MemoryCacheAnalyzer(new Analyzer()),
    ) {
        parent::__construct($routeParser, $dataGenerator);
    }

    /**
     * @param string $route
     * @param string|array $handler
     * @phpstan-param class-string|array{class-string, string} $handler
     * @param array<string, scalar> $extraArguments
     */
    public function addRoute($httpMethod, $route, $handler, array $extraArguments = []): void
    {
        if (is_string($handler)) {
            $handler = [$handler, '__invoke'];
        }

        if (!class_exists($handler[0])) {
            // @todo Figure out how to support classes in a container not indexed by class name.
            throw new \RuntimeException(sprintf('Class %s not found.', $handler[0]));
        }

        $classDef = $this->analyzer->analyze($handler[0], ActionClass::class);
        $methodDef = $classDef->methods[$handler[1]] ?? throw new \RuntimeException(sprintf('Method %s of class %s not found.', $handler[1], $handler[0]));
        $routeDef = new RouteDefinition($handler, $methodDef, $extraArguments);

        parent::addRoute($httpMethod, $route, $routeDef); // TODO: Change the autogenerated stub
    }

    /**
     * @param string $route
     * @phpstan-param class-string|array{class-string, string} $handler
     * @param array<string, scalar> $extraArguments
     */
    public function get($route, $handler, array $extraArguments = []): void
    {
        $this->addRoute('GET', $route, $handler, $extraArguments);
    }

    /**
     * @param string $route
     * @phpstan-param class-string|array{class-string, string} $handler
     * @param array<string, scalar> $extraArguments
     */
    public function post($route, $handler, array $extraArguments = []): void
    {
        $this->addRoute('POST', $route, $handler, $extraArguments);
    }

    /**
     * @param string $route
     * @phpstan-param class-string|array{class-string, string} $handler
     * @param array<string, scalar> $extraArguments
     */
    public function put($route, $handler, array $extraArguments = []): void
    {
        $this->addRoute('PUT', $route, $handler, $extraArguments);
    }

    /**
     * @param string $route
     * @phpstan-param class-string|array{class-string, string} $handler
     * @param array<string, scalar> $extraArguments
     */
    public function delete($route, $handler, array $extraArguments = []): void
    {
        $this->addRoute('DELETE', $route, $handler, $extraArguments);
    }

    /**
     * @param string $route
     * @phpstan-param class-string|array{class-string, string} $handler
     * @param array<string, scalar> $extraArguments
     */
    public function patch($route, $handler, array $extraArguments = []): void
    {
        $this->addRoute('PATCH', $route, $handler, $extraArguments);
    }

    /**
     * @param string $route
     * @phpstan-param class-string|array{class-string, string} $handler
     * @param array<string, scalar> $extraArguments
     */
    public function head($route, $handler, array $extraArguments = []): void
    {
        $this->addRoute('HEAD', $route, $handler, $extraArguments);
    }
}
